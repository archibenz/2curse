% filepath: /Users/alexander/Documents/Education/2curse/OPT/lab3/lab3.m

%==========================================================================
% РАЗДЕЛ 1. ИСХОДНЫЕ ДАННЫЕ (ГРАФ Б, ВАРИАНТ 10)
%==========================================================================

% Матрица смежности графа (0, если нет пути)
adjacency_matrix = [
    0,  5,  9,  0,  0,  0,  0, 12;  
    5,  0,  3,  7,  0,  0,  0,  0;  
    9,  3,  0,  4,  8,  0,  0,  0;  
    0,  7,  4,  0,  6,  0, 10,  0;  
    0,  0,  8,  6,  0,  5,  0, 15;  
    0,  0,  0,  0,  5,  0,  7,  0;  
    0,  0,  0, 10,  0,  7,  0,  9;  
    12, 0,  0,  0, 15,  0,  9,  0  
];

% Веса вершин (количество абонентов в каждом пункте)
weights = [90, 100, 110, 70, 50, 60, 80, 100]; 

%==========================================================================
% РАЗДЕЛ 2. ПОИСК КРАТЧАЙШИХ ПУТЕЙ (ФЛОЙД-УОРШЕЛЛ)
%==========================================================================

n = size(adjacency_matrix, 1);
Dij = adjacency_matrix;
% Заполняем "бесконечностью"
for i = 1:n
    for j = 1:n
        if Dij(i,j) == 0 && i ~= j
            Dij(i,j) = Inf;
        end
    end
end

% Диагональ (расстояние до себя) = 0
for i = 1:n
    Dij(i,i) = 0;
end

% Сохраним исходную матрицу расстояний для проверки
original_Dij = Dij;

for k = 1:n
    for i = 1:n
        for j = 1:n
            if Dij(i,k) ~= Inf && Dij(k,j) ~= Inf
                Dij(i,j) = min(Dij(i,j), Dij(i,k) + Dij(k,j));
            end
        end
    end
end

%--------------------------------------------------------------------------
% 2.1 Проверка корректности полученных расстояний
%--------------------------------------------------------------------------
violations = 0;
for i = 1:n
    for j = 1:n
        for k = 1:n
            if i ~= j && j ~= k && i ~= k
                if Dij(i,j) > Dij(i,k) + Dij(k,j)
                    violations = violations + 1;
                    printf('Нарушение неравенства треугольника: d(%d,%d) > d(%d,%d) + d(%d,%d): %.1f > %.1f + %.1f\n', 
                           i, j, i, k, k, j, Dij(i,j), Dij(i,k), Dij(k,j));
                end
            end
        end
    end
end

if violations == 0
    printf('[УСПЕХ] Проверка неравенства треугольника пройдена успешно\n\n');
else
    printf('[ОШИБКА] Обнаружено %d нарушений неравенства треугольника\n\n', violations);
    
    % Если есть нарушения, убедимся, что алгоритм Флойда-Уоршелла выполнен корректно
    printf('Перепроверяем алгоритм Флойда-Уоршелла...\n');
    Dij = original_Dij;
    
    for k = 1:n
        for i = 1:n
            for j = 1:n
                if i ~= j && i ~= k && j ~= k
                    if Dij(i,k) ~= Inf && Dij(k,j) ~= Inf
                        if Dij(i,j) > Dij(i,k) + Dij(k,j) || Dij(i,j) == Inf
                            Dij(i,j) = Dij(i,k) + Dij(k,j);
                        end
                    end
                end
            end
        end
    end
    
    printf('Перепроверка завершена\n\n');
end

%--------------------------------------------------------------------------
% 2.2 Вывод матрицы кратчайших путей
%--------------------------------------------------------------------------
printf('Матрица кратчайших путей (Dij):\n');
printf('Строки и столбцы — номера населённых пунктов (x1, x2, ..., x8)\n');

% Более аккуратный вывод матрицы
printf('\n');
for i = 1:n
    for j = 1:n
        printf('%4.1f ', Dij(i, j));
    end
    printf('\n');
end
printf('\n');

%==========================================================================
% РАЗДЕЛ 3. МИНИМАКСНАЯ ЗАДАЧА (ЦЕНТР ГРАФА)
%==========================================================================

% Находим максимальное расстояние для каждой вершины
max_distances = zeros(1, n);
for i = 1:n
    max_distances(i) = max(Dij(i, :));
end

% Выбираем вершину с минимальным из этих максимумов
[~, minimax_index] = min(max_distances);

printf('МИНИМАКСНАЯ ЗАДАЧА: Поиск центра графа (узла радиосети)\n');
printf('------------------------------------------------------------------\n');
printf('Максимальные расстояния для каждой вершины:\n');
for i = 1:n
    printf('Вершина x%d: max расстояние = %.1f\n', i, max_distances(i));
end

printf('\n[РЕЗУЛЬТАТ] Оптимальный узел радиодоступа (центр графа): x%d\n\n', minimax_index);

%==========================================================================
% РАЗДЕЛ 4. МИНИСУММНАЯ ЗАДАЧА (МЕДИАНА ГРАФА)
%==========================================================================

% Умножаем на вес и суммируем
sum_distances = zeros(1, n);
for i = 1:n
    weighted_dist = 0;
    for j = 1:n
        weighted_dist = weighted_dist + Dij(i, j) * weights(j);
    end
    sum_distances(i) = weighted_dist;
end

% Минимальная сумма
[~, median_index] = min(sum_distances);

printf('МИНИСУММНАЯ ЗАДАЧА: Поиск медианы графа (оптимального узла проводного доступа)\n');
printf('------------------------------------------------------------------\n');
printf('Суммы расстояний с учётом абонентов:\n');
for i = 1:n
    printf('Вершина x%d: сумма расстояний = %.1f\n', i, sum_distances(i));
end

printf('\n[РЕЗУЛЬТАТ] Оптимальное расположение проводного узла: x%d\n', median_index);
